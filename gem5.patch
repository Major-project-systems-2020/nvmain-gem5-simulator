diff --git a/configs/common/Options.py b/configs/common/Options.py
index f6fa0d031..c755f87ff 100644
--- a/configs/common/Options.py
+++ b/configs/common/Options.py
@@ -80,6 +80,12 @@ def _listPlatformTypes(option, opt, value, parser):
 # being used, and consequently no CPUs, but rather various types of
 # testers and traffic generators.
 def addNoISAOptions(parser):
+    # Check for extra nvmain configuration override options
+    for arg in sys.argv:
+        if arg[:9] == "--nvmain-":
+            parser.add_option(arg, type="string", default="NULL",
+                       help="Set NVMain configuration value for a parameter")
+
     parser.add_option("-n", "--num-cpus", type="int", default=1)
     parser.add_option("--sys-voltage", action="store", type="string",
                       default='1.0V',
diff --git a/configs/example/simple.py b/configs/example/simple.py
new file mode 100644
index 000000000..50a396a57
--- /dev/null
+++ b/configs/example/simple.py
@@ -0,0 +1,95 @@
+# -*- coding: utf-8 -*-
+# Copyright (c) 2015 Jason Power
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Jason Power
+
+""" This file creates a barebones system and executes 'hello', a simple Hello
+World application.
+
+This config file assumes that the x86 ISA was built.
+See gem5/configs/learning_gem5/part1/simple.py for a general script.
+
+"""
+
+# import the m5 (gem5) library created when gem5 is built
+import m5
+# import all of the SimObjects
+from m5.objects import *
+
+# create the system we are going to simulate
+system = System()
+
+# Set the clock fequency of the system (and all of its children)
+system.clk_domain = SrcClockDomain()
+system.clk_domain.clock = '1GHz'
+system.clk_domain.voltage_domain = VoltageDomain()
+
+# Set up the system
+system.mem_mode = 'timing'               # Use timing accesses
+system.mem_ranges = [AddrRange('512MB')] # Create an address range
+
+# Create a simple CPU
+system.cpu = TimingSimpleCPU()
+
+# Create a memory bus, a coherent crossbar, in this case
+system.membus = SystemXBar()
+
+# Hook the CPU ports up to the membus
+system.cpu.icache_port = system.membus.slave
+system.cpu.dcache_port = system.membus.slave
+
+# create the interrupt controller for the CPU and connect to the membus
+system.cpu.createInterruptController()
+system.cpu.interrupts[0].pio = system.membus.master
+system.cpu.interrupts[0].int_master = system.membus.slave
+system.cpu.interrupts[0].int_slave = system.membus.master
+
+# Create a DDR3 memory controller and connect it to the membus
+system.mem_ctrl = DDR3_1600_8x8()
+system.mem_ctrl.range = system.mem_ranges[0]
+system.mem_ctrl.port = system.membus.master
+
+# Connect the system up to the membus
+system.system_port = system.membus.slave
+
+# Create a process for a simple "Hello World" application
+process = Process()
+# Set the command
+# cmd is a list which begins with the executable (like argv)
+process.cmd = ['tests/test-progs/hello/bin/x86/linux/hello']
+# Set the cpu to use the process as its workload and create thread contexts
+system.cpu.workload = process
+system.cpu.createThreads()
+
+# set up the root SimObject and start the simulation
+root = Root(full_system = False, system = system)
+# instantiate all of the objects we've created above
+m5.instantiate()
+
+print ("Beginning simulation!")
+exit_event = m5.simulate()
+print ('Exiting @ tick %i because %s' % (m5.curTick(), exit_event.getCause()))
diff --git a/src/mem/NVMainMemory.py b/src/mem/NVMainMemory.py
new file mode 100644
index 000000000..5063aa607
--- /dev/null
+++ b/src/mem/NVMainMemory.py
@@ -0,0 +1,90 @@
+# Copyright (c) 2012-2013 Pennsylvania State University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Matt Poremba
+#          Tao Zhang
+
+import optparse
+import sys
+
+from m5.params import *
+from AbstractMemory import *
+from ClockDomain import *
+
+class NVMainMemory(AbstractMemory):
+    type = 'NVMainMemory'
+    cxx_header = 'mem/nvmain_mem.hh'
+    port = SlavePort("Slave ports")
+    atomic_mode = Param.Bool(False, "Enable to use NVMain in atomic mode rather than latency/variance")
+    atomic_latency = Param.Latency('30ns', "Request latency in atomic mode")
+    atomic_variance = Param.Latency('30ns', "Request latency in atomic mode")
+
+    config = Param.String("", "")
+    configparams = Param.String("", "")
+    configvalues = Param.String("", "")
+    NVMainWarmUp = Param.Bool(False, "Enable to warm up the internal cache in NVMain")
+
+
+    def __init__(self, *args, **kwargs):
+        AbstractMemory.__init__(self, *args, **kwargs)
+
+        config_params = ""
+        config_values = ""
+
+        for arg in sys.argv:
+            if arg[:9] == "--nvmain-":
+                param_pair = arg.split('=', 1)
+                param_name = (param_pair[0])[9:]
+                if len(param_pair) > 1:
+                    param_value = param_pair[1]
+                else:
+                    param_value = ""
+
+                # Handle special cases
+                if param_name == "atomic":
+                    self.atomic_mode = True
+                elif param_name == "atomic-latency":
+                    self.atomic_latency = param_value
+                elif param_name == "atomic-variance":
+                    self.atomic_variance = param_value
+                elif param_name == "warmup":
+                    self.NVMainWarmUp = True
+                elif param_name == "config":
+                    self.config = param_value
+                else:
+                    print("Setting %s to %s" % (param_name, param_value))
+                    if config_params == "":
+                        config_params = param_name
+                    else:
+                        config_params = config_params + "," + param_name
+                    if config_values == "":
+                        config_values += param_value
+                    else:
+                        config_values = config_values + "," + param_value
+
+        self.configparams = config_params
+        self.configvalues = config_values
+
diff --git a/src/mem/SConscript b/src/mem/SConscript
index 95d8654b1..9d79a2947 100644
--- a/src/mem/SConscript
+++ b/src/mem/SConscript
@@ -94,6 +94,9 @@ if env['HAVE_DRAMSIM']:
     Source('dramsim2_wrapper.cc')
     Source('dramsim2.cc')
 
+SimObject('NVMainMemory.py')
+Source('nvmain_mem.cc')
+
 SimObject('MemChecker.py')
 Source('mem_checker.cc')
 Source('mem_checker_monitor.cc')
@@ -118,6 +121,8 @@ DebugFlag('MemoryAccess')
 DebugFlag('PacketQueue')
 DebugFlag('StackDist')
 DebugFlag("DRAMSim2")
+DebugFlag("NVMain")
+DebugFlag("NVMainMin")
 DebugFlag('HMCController')
 DebugFlag('SerialLink')
 
diff --git a/src/mem/nvmain_mem.cc b/src/mem/nvmain_mem.cc
new file mode 100644
index 000000000..d43842911
--- /dev/null
+++ b/src/mem/nvmain_mem.cc
@@ -0,0 +1,898 @@
+/*
+ * Copyright (c) 2012-2014 Pennsylvania State University
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#include "SimInterface/Gem5Interface/Gem5Interface.h"
+#include "mem/nvmain_mem.hh"
+#include "Utils/HookFactory.h"
+
+#include "base/random.hh"
+#include "base/statistics.hh"
+#include "debug/NVMain.hh"
+#include "debug/NVMainMin.hh"
+#include "config/the_isa.hh"
+
+using namespace NVM;
+
+// This members are singleton values used to hold the main instance of
+// NVMain and it's wake/sleep (i.e., timing/atomic) status. These are
+// needed since NVMain assumes a contiguous address range while gem5
+// ISAs generally do not. The multiple instances allow for the gem5
+// AddrRanges to be used normally while this class remapped to NVMains
+// contiguous region.
+NVMainMemory *NVMainMemory::masterInstance = NULL;
+
+NVMainMemory::NVMainMemory(const Params *p)
+    : AbstractMemory(p), clockEvent(this), respondEvent(this),
+      drainManager(NULL), lat(p->atomic_latency),
+      lat_var(p->atomic_variance), nvmain_atomic(p->atomic_mode),
+      NVMainWarmUp(p->NVMainWarmUp), port(name() + ".port", *this)
+{
+    char *cfgparams;
+    char *cfgvalues;
+    char *cparam, *cvalue;
+
+    char *saveptr1, *saveptr2;
+
+    nextEventCycle = 0;
+
+    m_nvmainPtr = NULL;
+    m_nacked_requests = false;
+
+    m_nvmainConfigPath = p->config;
+
+    m_nvmainConfig = new Config( );
+
+    m_nvmainConfig->Read( m_nvmainConfigPath );
+    std::cout << "NVMainControl: Reading NVMain config file: " << m_nvmainConfigPath << "." << std::endl;
+
+    clock = clockPeriod( );
+
+    m_avgAtomicLatency = 100.0f;
+    m_numAtomicAccesses = 0;
+
+    retryRead = false;
+    retryWrite = false;
+    retryResp = false;
+    m_requests_outstanding = 0;
+
+    /*
+     * Modified by Tao @ 01/22/2013
+     * multiple parameters can be manually specified
+     * please separate the parameters by comma ","
+     * For example,
+     *    configparams = tRCD,tCAS,tRP
+     *    configvalues = 8,8,8
+     */
+    cfgparams = (char *)p->configparams.c_str();
+    cfgvalues = (char *)p->configvalues.c_str();
+
+    for( cparam = strtok_r( cfgparams, ",", &saveptr1 ), cvalue = strtok_r( cfgvalues, ",", &saveptr2 )
+           ; (cparam && cvalue) ; cparam = strtok_r( NULL, ",", &saveptr1 ), cvalue = strtok_r( NULL, ",", &saveptr2) )
+    {
+        std::cout << "NVMain: Overriding parameter `" << cparam << "' with `" << cvalue << "'" << std::endl;
+        m_nvmainConfig->SetValue( cparam, cvalue );
+    }
+
+   BusWidth = m_nvmainConfig->GetValue( "BusWidth" );
+   tBURST = m_nvmainConfig->GetValue( "tBURST" );
+   RATE = m_nvmainConfig->GetValue( "RATE" );
+
+   lastWakeup = curTick();
+}
+
+
+NVMainMemory::~NVMainMemory()
+{
+    std::cout << "NVMain dtor called" << std::endl;
+}
+
+
+void
+NVMainMemory::init()
+{
+    if (!port.isConnected()) {
+        fatal("NVMainMemory %s is unconnected!\n", name());
+    } else {
+        port.sendRangeChange();
+    }
+
+    if( masterInstance == NULL )
+    {
+        masterInstance = this;
+
+        m_nvmainPtr = new NVM::NVMain( );
+        m_statsPtr = new NVM::Stats( );
+        m_nvmainSimInterface = new NVM::Gem5Interface( );
+        m_nvmainEventQueue = new NVM::EventQueue( );
+        m_nvmainGlobalEventQueue = new NVM::GlobalEventQueue( );
+        m_tagGenerator = new NVM::TagGenerator( 1000 );
+
+        m_nvmainConfig->SetSimInterface( m_nvmainSimInterface );
+
+        statPrinter.nvmainPtr = m_nvmainPtr;
+        statReseter.nvmainPtr = m_nvmainPtr;
+
+        if( m_nvmainConfig->KeyExists( "StatsFile" ) )
+        {
+            statPrinter.statStream.open( m_nvmainConfig->GetString( "StatsFile" ).c_str(),
+                                         std::ofstream::out | std::ofstream::app );
+        }
+
+        statPrinter.memory = this;
+        statPrinter.forgdb = this;
+
+        //registerExitCallback( &statPrinter );
+        ::Stats::registerDumpCallback( &statPrinter );
+        ::Stats::registerResetCallback( &statReseter );
+
+        SetEventQueue( m_nvmainEventQueue );
+        SetStats( m_statsPtr );
+        SetTagGenerator( m_tagGenerator );
+
+        m_nvmainGlobalEventQueue->SetFrequency( m_nvmainConfig->GetEnergy( "CPUFreq" ) * 1000000.0 );
+        SetGlobalEventQueue( m_nvmainGlobalEventQueue );
+
+        // TODO: Confirm global event queue frequency is the same as this SimObject's clock.
+
+        /*  Add any specified hooks */
+        std::vector<std::string>& hookList = m_nvmainConfig->GetHooks( );
+
+        for( size_t i = 0; i < hookList.size( ); i++ )
+        {
+            std::cout << "Creating hook " << hookList[i] << std::endl;
+
+            NVMObject *hook = HookFactory::CreateHook( hookList[i] );
+
+            if( hook != NULL )
+            {
+                AddHook( hook );
+                hook->SetParent( this );
+                hook->Init( m_nvmainConfig );
+            }
+            else
+            {
+                std::cout << "Warning: Could not create a hook named `"
+                    << hookList[i] << "'." << std::endl;
+            }
+        }
+
+        /* Setup child and parent modules. */
+        AddChild( m_nvmainPtr );
+        m_nvmainPtr->SetParent( this );
+        m_nvmainGlobalEventQueue->AddSystem( m_nvmainPtr, m_nvmainConfig );
+        m_nvmainPtr->SetConfig( m_nvmainConfig );
+
+        masterInstance->allInstances.push_back(this);
+    }
+    else
+    {
+        masterInstance->allInstances.push_back(this);
+        masterInstance->otherInstance = this;
+    }
+}
+
+
+void NVMainMemory::startup()
+{
+    DPRINTF(NVMain, "NVMainMemory: startup() called.\n");
+    DPRINTF(NVMainMin, "NVMainMemory: startup() called.\n");
+
+    /*
+     *  Schedule the initial event. Needed for warmup and timing mode.
+     *  If we are in atomic/fast-forward, wakeup will be disabled upon
+     *  the first atomic request receieved in recvAtomic().
+     */
+    if (!masterInstance->clockEvent.scheduled())
+        schedule(masterInstance->clockEvent, curTick() + clock);
+
+    lastWakeup = curTick();
+}
+
+
+void NVMainMemory::wakeup()
+{
+    DPRINTF(NVMain, "NVMainMemory: wakeup() called.\n");
+    DPRINTF(NVMainMin, "NVMainMemory: wakeup() called.\n");
+
+    schedule(masterInstance->clockEvent, clockEdge());
+
+    lastWakeup = curTick();
+}
+
+
+BaseSlavePort &
+NVMainMemory::getPort(const std::string& if_name, PortID idx)
+{
+    //if (if_name != "port") {
+    //    return MemObject::getSlavePort(if_name, idx);
+    //} else {
+        return port;
+    //}
+}
+
+
+void NVMainMemory::NVMainStatPrinter::process()
+{
+    assert(nvmainPtr != NULL);
+
+    assert(curTick() >= memory->lastWakeup);
+    Tick stepCycles = (curTick() - memory->lastWakeup) / memory->clock;
+
+    memory->m_nvmainGlobalEventQueue->Cycle( stepCycles );
+
+    nvmainPtr->CalculateStats();
+    std::ostream& refStream = (statStream.is_open()) ? statStream : std::cout;
+    nvmainPtr->GetStats()->PrintAll( refStream );
+}
+
+
+void NVMainMemory::NVMainStatReseter::process()
+{
+    assert(nvmainPtr != NULL);
+
+    nvmainPtr->ResetStats();
+    nvmainPtr->GetStats()->ResetAll( );
+}
+
+
+NVMainMemory::MemoryPort::MemoryPort(const std::string& _name, NVMainMemory& _memory)
+    : SlavePort(_name, &_memory), memory(_memory), forgdb(_memory)
+{
+
+}
+
+
+AddrRangeList NVMainMemory::MemoryPort::getAddrRanges() const
+{
+    AddrRangeList ranges;
+    ranges.push_back(memory.getAddrRange());
+    return ranges;
+}
+
+
+void
+NVMainMemory::SetRequestData(NVMainRequest *request, PacketPtr pkt)
+{
+    uint8_t *hostAddr;
+
+    request->data.SetSize( pkt->getSize() );
+    request->oldData.SetSize( pkt->getSize() );
+
+    if (pkt->isRead())
+    {
+        Request *dataReq = new Request(pkt->getAddr(), pkt->getSize(), 0, Request::funcMasterId);
+        Packet *dataPkt = new Packet((RequestPtr)dataReq, MemCmd::ReadReq);
+        dataPkt->allocate();
+        doFunctionalAccess(dataPkt);
+
+        hostAddr = new uint8_t[ pkt->getSize() ];
+        memcpy( hostAddr, dataPkt->getPtr<uint8_t>(), pkt->getSize() );
+
+        for(int i = 0; i < pkt->getSize(); i++ )
+        {
+            request->oldData.SetByte(i, *(hostAddr + i));
+            request->data.SetByte(i, *(hostAddr + i));
+        }
+
+        delete dataPkt;
+        delete dataReq;
+        delete [] hostAddr;
+    }
+    else
+    {
+        Request *dataReq = new Request(pkt->getAddr(), pkt->getSize(), 0, Request::funcMasterId);
+        Packet *dataPkt = new Packet((RequestPtr)dataReq, MemCmd::ReadReq);
+        dataPkt->allocate();
+        doFunctionalAccess(dataPkt);
+
+        uint8_t *hostAddrT = new uint8_t[ pkt->getSize() ];
+        memcpy( hostAddrT, dataPkt->getPtr<uint8_t>(), pkt->getSize() );
+
+        hostAddr = new uint8_t[ pkt->getSize() ];
+        memcpy( hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize() );
+
+        for(int i = 0; i < pkt->getSize(); i++ )
+        {
+            request->oldData.SetByte(i, *(hostAddrT + i));
+            request->data.SetByte(i, *(hostAddr + i));
+        }
+
+        delete dataPkt;
+        delete dataReq;
+        delete [] hostAddrT;
+        delete [] hostAddr;
+    }
+}
+
+
+Tick
+NVMainMemory::MemoryPort::recvAtomic(PacketPtr pkt)
+{
+    if (pkt->cacheResponding())
+        return 0;
+
+    /*
+     * calculate the latency. Now it is only random number
+     */
+    Tick latency = memory.lat;
+
+    if (memory.lat_var != 0)
+        latency += random_mt.random<Tick>(0, memory.lat_var);
+
+    /*
+     *  if NVMain also needs the packet to warm up the inline cache, create the request
+     */
+    if( memory.NVMainWarmUp )
+    {
+        NVMainRequest *request = new NVMainRequest( );
+
+        memory.SetRequestData( request, pkt );
+
+        if( !pkt->isRead() && !pkt->isWrite() )
+        {
+            // if it is neither read nor write, just return
+            // well, speed may suffer a little bit...
+            return latency;
+        }
+
+        /* initialize the request so that NVMain can correctly serve it */
+        request->access = UNKNOWN_ACCESS;
+        request->address.SetPhysicalAddress(pkt->req->getPaddr());
+        request->status = MEM_REQUEST_INCOMPLETE;
+        request->type = (pkt->isRead()) ? READ : WRITE;
+        request->owner = (NVMObject *)&memory;
+        if(pkt->req->hasPC()) request->programCounter = pkt->req->getPC();
+        if(pkt->req->hasContextId()) request->threadId = pkt->req->contextId();
+
+        /*
+         * Issue the request to NVMain as an atomic request
+         */
+        memory.masterInstance->m_nvmainPtr->IssueAtomic(request);
+
+        delete request;
+    }
+
+    /*
+     * do the memory access to get the read data and change the response tag
+     */
+    memory.access(pkt);
+
+    return latency;
+}
+
+
+void
+NVMainMemory::MemoryPort::recvFunctional(PacketPtr pkt)
+{
+    pkt->pushLabel(memory.name());
+
+    memory.doFunctionalAccess(pkt);
+
+    for( std::deque<PacketPtr>::iterator i = memory.responseQueue.begin();
+        i != memory.responseQueue.end(); ++i );
+       //pkt->checkFunctional(*i);
+
+    pkt->popLabel();
+}
+
+
+bool
+NVMainMemory::MemoryPort::recvTimingReq(PacketPtr pkt)
+{
+    /* added by Tao @ 01/24/2013, just copy the code from SimpleMemory */
+    /// @todo temporary hack to deal with memory corruption issues until
+    /// 4-phase transactions are complete
+    for (int x = 0; x < memory.pendingDelete.size(); x++)
+        delete memory.pendingDelete[x];
+    memory.pendingDelete.clear();
+
+    if (pkt->cacheResponding()) {
+        memory.pendingDelete.push_back(pkt);
+        return true;
+    }
+
+    if (!pkt->isRead() && !pkt->isWrite()) {
+        DPRINTF(NVMain, "NVMainMemory: Received a packet that is neither read nor write.\n");
+        DPRINTF(NVMainMin, "NVMainMemory: Received a packet that is neither read nor write.\n");
+
+        bool needsResponse = pkt->needsResponse();
+
+        memory.access(pkt);
+        if (needsResponse) {
+            assert(pkt->isResponse());
+
+            pkt->headerDelay = pkt->payloadDelay = 0;
+
+            memory.responseQueue.push_back(pkt);
+
+            memory.ScheduleResponse( );
+        } else {
+            memory.pendingDelete.push_back(pkt);
+        }
+
+        return true;
+    }
+
+
+    if (memory.retryRead || memory.retryWrite)
+    {
+        DPRINTF(NVMain, "nvmain_mem.cc: Received request while waiting for retry!\n");
+        DPRINTF(NVMainMin, "nvmain_mem.cc: Received request while waiting for retry!\n");
+        return false;
+    }
+
+    // Bus latency is modeled in NVMain.
+    pkt->headerDelay = pkt->payloadDelay = 0;
+
+    NVMainRequest *request = new NVMainRequest( );
+
+    bool canQueue, enqueued = false;
+
+    memory.SetRequestData( request, pkt );
+
+    /*
+     *  NVMain expects linear addresses, so hack: If we are not the master
+     *  instance, assume there are two channels because 3GB-4GB is skipped
+     *  in X86 and subtract 1GB.
+     *
+     *  TODO: Have each channel communicate it's address range to determine
+     *  this fix up value.
+     */
+    uint64_t addressFixUp = 0;
+#if THE_ISA == X86_ISA
+    if( masterInstance != &memory )
+    {
+        addressFixUp = 0x40000000;
+    }
+#elif THE_ISA == ARM_ISA
+    /* 
+     *  ARM regions are 2GB - 4GB followed by 34 GB - 64 GB. Work for up to
+     *  34 GB of memory. Further regions from 512 GB - 992 GB.
+     */
+    addressFixUp = (masterInstance == &memory) ? 0x80000000 : 0x800000000;
+#endif
+
+    request->access = UNKNOWN_ACCESS;
+    request->address.SetPhysicalAddress(pkt->req->getPaddr() - addressFixUp);
+    request->status = MEM_REQUEST_INCOMPLETE;
+    request->type = (pkt->isRead()) ? READ : WRITE;
+    request->owner = (NVMObject *)&memory;
+
+    if(pkt->req->hasPC()) request->programCounter = pkt->req->getPC();
+    if(pkt->req->hasContextId()) request->threadId = pkt->req->contextId();
+
+    /* Call hooks here manually, since there is no one else to do it. */
+    std::vector<NVMObject *>& preHooks  = memory.masterInstance->GetHooks( NVMHOOK_PREISSUE );
+    std::vector<NVMObject *>& postHooks = memory.masterInstance->GetHooks( NVMHOOK_POSTISSUE );
+    std::vector<NVMObject *>::iterator it;
+
+    canQueue = memory.masterInstance->GetChild( )->IsIssuable( request );
+
+    if( canQueue )
+    {
+        /* Call pre-issue hooks */
+        for( it = preHooks.begin(); it != preHooks.end(); it++ )
+        {
+            (*it)->SetParent( memory.masterInstance );
+            (*it)->IssueCommand( request );
+        }
+
+        enqueued = memory.masterInstance->GetChild( )->IssueCommand(request);
+        assert( enqueued == true );
+
+        NVMainMemoryRequest *memRequest = new NVMainMemoryRequest;
+
+        memRequest->request = request;
+        memRequest->packet = pkt;
+        memRequest->issueTick = curTick();
+        memRequest->atomic = false;
+
+        DPRINTF(NVMain, "nvmain_mem.cc: Enqueued Mem request for 0x%x of type %s\n", request->address.GetPhysicalAddress( ), ((pkt->isRead()) ? "READ" : "WRITE") );
+
+        /* See if we need to reschedule the wakeup event sooner. */
+        ncycle_t nextEvent = memory.masterInstance->m_nvmainGlobalEventQueue->GetNextEvent(NULL);
+        DPRINTF(NVMain, "NVMainMemory: Next event after issue is %d\n", nextEvent);
+        if( nextEvent < memory.nextEventCycle && masterInstance->clockEvent.scheduled() )
+        {
+            ncycle_t currentCycle = memory.masterInstance->m_nvmainGlobalEventQueue->GetCurrentCycle();
+
+            //assert(nextEvent >= currentCycle);
+            ncycle_t stepCycles;
+            if( nextEvent > currentCycle )
+                stepCycles = nextEvent - currentCycle;
+            else
+                stepCycles = 1;
+
+            Tick nextWake = curTick() + memory.clock * static_cast<Tick>(stepCycles);
+
+            DPRINTF(NVMain, "NVMainMemory: Next event: %d CurrentCycle: %d\n", nextEvent, currentCycle);
+            DPRINTF(NVMain, "NVMainMemory: Rescheduled wake at %d after %d cycles\n", nextWake, stepCycles);
+
+            memory.nextEventCycle = nextEvent;
+            memory.ScheduleClockEvent( nextWake );
+        }
+        else if( !masterInstance->clockEvent.scheduled() )
+        {
+            ncycle_t currentCycle = memory.masterInstance->m_nvmainGlobalEventQueue->GetCurrentCycle();
+
+            //assert(nextEvent >= currentCycle);
+            ncycle_t stepCycles = nextEvent - currentCycle;
+            if( stepCycles == 0 || nextEvent < currentCycle )
+                stepCycles = 1;
+
+            Tick nextWake = curTick() + memory.clock * static_cast<Tick>(stepCycles);
+
+            memory.nextEventCycle = nextEvent;
+            memory.ScheduleClockEvent( nextWake );
+        }
+
+        memory.masterInstance->m_request_map.insert( std::pair<NVMainRequest *, NVMainMemoryRequest *>( request, memRequest ) );
+        memory.m_requests_outstanding++;
+
+        /*
+         *  It seems gem5 will block until the packet gets a response, so create a copy of the request, so
+         *  the memory controller has it, then delete the original copy to respond to the packet.
+         */
+        if( request->type == WRITE )
+        {
+            NVMainMemoryRequest *requestCopy = new NVMainMemoryRequest( );
+
+            requestCopy->request = new NVMainRequest( );
+            *(requestCopy->request) = *request;
+            requestCopy->packet = pkt;
+            requestCopy->issueTick = curTick();
+            requestCopy->atomic = false;
+
+            memRequest->packet = NULL;
+
+            memory.masterInstance->m_request_map.insert( std::pair<NVMainRequest *, NVMainMemoryRequest *>( requestCopy->request, requestCopy ) );
+            memory.m_requests_outstanding++;
+
+            memory.RequestComplete( requestCopy->request );
+        }
+
+        /* Call post-issue hooks. */
+        if( request != NULL )
+        {
+            for( it = postHooks.begin(); it != postHooks.end(); it++ )
+            {
+                (*it)->SetParent( &memory );
+                (*it)->IssueCommand( request );
+            }
+        }
+    }
+    else
+    {
+        DPRINTF(NVMain, "nvmain_mem.cc: Can not enqueue Mem request for 0x%x of type %s\n", request->address.GetPhysicalAddress( ), ((pkt->isRead()) ? "READ" : "WRITE") );
+        DPRINTF(NVMainMin, "nvmain_mem.cc: Can not enqueue Mem request for 0x%x of type %s\n", request->address.GetPhysicalAddress( ), ((pkt->isRead()) ? "READ" : "WRITE") );
+
+        if (pkt->isRead())
+        {
+            memory.retryRead = true;
+        }
+        else
+        {
+            memory.retryWrite = true;
+        }
+
+        delete request;
+        request = NULL;
+    }
+
+    return enqueued;
+}
+
+
+
+Tick NVMainMemory::doAtomicAccess(PacketPtr pkt)
+{
+    access(pkt);
+    return static_cast<Tick>(m_avgAtomicLatency);
+}
+
+
+
+void NVMainMemory::doFunctionalAccess(PacketPtr pkt)
+{
+    functionalAccess(pkt);
+}
+
+
+DrainState NVMainMemory::drain()
+{
+    if( !masterInstance->m_request_map.empty() )
+    {
+        return DrainState::Draining;
+    }
+    else
+    {
+        return DrainState::Drained;
+    }
+}
+
+
+void NVMainMemory::MemoryPort::recvRespRetry( )
+{
+    memory.recvRetry( );
+}
+
+
+void NVMainMemory::MemoryPort::recvRetry( )
+{
+    memory.recvRetry( );
+}
+
+
+void NVMainMemory::recvRetry( )
+{
+    DPRINTF(NVMain, "NVMainMemory: recvRetry() called.\n");
+    DPRINTF(NVMainMin, "NVMainMemory: recvRetry() called.\n");
+
+    retryResp = false;
+    SendResponses( );
+}
+
+
+bool NVMainMemory::RequestComplete(NVM::NVMainRequest *req)
+{
+    bool isRead = (req->type == READ || req->type == READ_PRECHARGE);
+    bool isWrite = (req->type == WRITE || req->type == WRITE_PRECHARGE);
+
+    /* Ignore bus read/write requests generated by the banks. */
+    if( req->type == BUS_WRITE || req->type == BUS_READ )
+    {
+        delete req;
+        return true;
+    }
+
+    NVMainMemoryRequest *memRequest;
+    std::map<NVMainRequest *, NVMainMemoryRequest *>::iterator iter;
+
+    // Find the mem request pointer in the map.
+    assert(masterInstance->m_request_map.count(req) != 0);
+    iter = masterInstance->m_request_map.find(req);
+    memRequest = iter->second;
+
+    if(!memRequest->atomic)
+    {
+        bool respond = false;
+
+        NVMainMemory *ownerInstance = dynamic_cast<NVMainMemory *>( req->owner );
+        assert( ownerInstance != NULL );
+
+        if( memRequest->packet )
+        {
+            respond = memRequest->packet->needsResponse();
+            ownerInstance->access(memRequest->packet);
+        }
+
+        for( auto retryIter = masterInstance->allInstances.begin(); 
+             retryIter != masterInstance->allInstances.end(); retryIter++ )
+        {
+            if( (*retryIter)->retryRead && (isRead || isWrite) )
+            {
+                (*retryIter)->retryRead = false;
+                (*retryIter)->port.sendRetryReq();
+            }
+            if( (*retryIter)->retryWrite && (isRead || isWrite) )
+            {
+                (*retryIter)->retryWrite = false;
+                (*retryIter)->port.sendRetryReq();
+            }
+        }
+
+        DPRINTF(NVMain, "Completed Mem request for 0x%x of type %s\n", req->address.GetPhysicalAddress( ), (isRead ? "READ" : "WRITE"));
+
+        if(respond)
+        {
+            ownerInstance->responseQueue.push_back(memRequest->packet);
+            ownerInstance->ScheduleResponse( );
+
+            delete req;
+            delete memRequest;
+        }
+        else
+        {
+            if( memRequest->packet )
+                ownerInstance->pendingDelete.push_back(memRequest->packet);
+
+            CheckDrainState( );
+
+            delete req;
+            delete memRequest;
+        }
+    }
+    else
+    {
+        delete req;
+        delete memRequest;
+    }
+
+
+    masterInstance->m_request_map.erase(iter);
+    //assert(m_requests_outstanding > 0);
+    m_requests_outstanding--;
+
+    return true;
+}
+
+
+void NVMainMemory::SendResponses( )
+{
+    if( responseQueue.empty() || retryResp == true )
+        return;
+
+
+    bool success = port.sendTimingResp( responseQueue.front() );
+
+    if( success )
+    {
+        DPRINTF(NVMain, "NVMainMemory: Sending response.\n");
+
+        responseQueue.pop_front( );
+
+        if( !responseQueue.empty( ) )
+            ScheduleResponse( );
+
+        CheckDrainState( );
+    }
+    else
+    {
+        DPRINTF(NVMain, "NVMainMemory: Retrying response.\n");
+        DPRINTF(NVMainMin, "NVMainMemory: Retrying response.\n");
+
+        retryResp = true;
+    }
+}
+
+
+void NVMainMemory::CheckDrainState( )
+{
+    if( drainManager != NULL && masterInstance->m_request_map.empty() )
+    {
+        DPRINTF(NVMain, "NVMainMemory: Drain completed.\n");
+        DPRINTF(NVMainMin, "NVMainMemory: Drain completed.\n");
+
+        drainManager->signalDrainDone( );
+        drainManager = NULL;
+    }
+}
+
+
+void NVMainMemory::ScheduleResponse( )
+{
+    if( !respondEvent.scheduled( ) )
+        schedule(respondEvent, curTick() + clock);
+}
+
+
+void NVMainMemory::ScheduleClockEvent( Tick nextWake )
+{
+    if( !masterInstance->clockEvent.scheduled() )
+        schedule(masterInstance->clockEvent, nextWake);
+    else
+        reschedule(masterInstance->clockEvent, nextWake);
+}
+
+
+void NVMainMemory::serialize(CheckpointOut &cp) const
+{
+    if (masterInstance != this)
+        return;
+
+    std::string nvmain_chkpt_dir = "";
+
+    if( m_nvmainConfig->KeyExists( "CheckpointDirectory" ) )
+        nvmain_chkpt_dir = m_nvmainConfig->GetString( "CheckpointDirectory" );
+
+    if( nvmain_chkpt_dir != "" )
+    {
+        std::cout << "NVMainMemory: Writing to checkpoint directory " << nvmain_chkpt_dir << std::endl;
+
+        m_nvmainPtr->CreateCheckpoint( nvmain_chkpt_dir );
+    }
+}
+
+
+void NVMainMemory::unserialize(CheckpointIn &cp)
+{
+    if (masterInstance != this)
+        return;
+
+    std::string nvmain_chkpt_dir = "";
+
+    if( m_nvmainConfig->KeyExists( "CheckpointDirectory" ) )
+        nvmain_chkpt_dir = m_nvmainConfig->GetString( "CheckpointDirectory" );
+
+    if( nvmain_chkpt_dir != "" )
+    {
+        std::cout << "NVMainMemory: Reading from checkpoint directory " << nvmain_chkpt_dir << std::endl;
+
+        m_nvmainPtr->RestoreCheckpoint( nvmain_chkpt_dir );
+    }
+}
+
+
+void NVMainMemory::tick( )
+{
+    // Cycle memory controller
+    if (masterInstance == this)
+    {
+        /* Keep NVMain in sync with gem5. */
+        assert(curTick() >= lastWakeup);
+        ncycle_t stepCycles = (curTick() - lastWakeup) / clock;
+
+        DPRINTF(NVMain, "NVMainMemory: Stepping %d cycles\n", stepCycles);
+        m_nvmainGlobalEventQueue->Cycle( stepCycles );
+
+        lastWakeup = curTick();
+
+        ncycle_t nextEvent;
+
+        nextEvent = m_nvmainGlobalEventQueue->GetNextEvent(NULL);
+        if( nextEvent != std::numeric_limits<ncycle_t>::max() )
+        {
+            ncycle_t currentCycle = m_nvmainGlobalEventQueue->GetCurrentCycle();
+
+            assert(nextEvent >= currentCycle);
+            stepCycles = nextEvent - currentCycle;
+
+            Tick nextWake = curTick() + clock * static_cast<Tick>(stepCycles);
+
+            DPRINTF(NVMain, "NVMainMemory: Next event: %d CurrentCycle: %d\n", nextEvent, currentCycle);
+            DPRINTF(NVMain, "NVMainMemory: Schedule wake for %d\n", nextWake);
+
+            nextEventCycle = nextEvent;
+            ScheduleClockEvent( nextWake );
+        }
+    }
+}
+
+
+NVMainMemory *
+NVMainMemoryParams::create()
+{
+    return new NVMainMemory(this);
+}
+
diff --git a/src/mem/nvmain_mem.hh b/src/mem/nvmain_mem.hh
new file mode 100644
index 000000000..3372e8802
--- /dev/null
+++ b/src/mem/nvmain_mem.hh
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2012-2013 Pennsylvania State University
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#ifndef __MEM_NVMAIN_MEM_HH__
+#define __MEM_NVMAIN_MEM_HH__
+
+
+#include <fstream>
+#include <ostream>
+
+#include "NVM/nvmain.h"
+#include "base/callback.hh"
+#include "include/NVMTypes.h"
+#include "include/NVMainRequest.h"
+#include "mem/abstract_mem.hh"
+#include "mem/tport.hh"
+#include "params/NVMainMemory.hh"
+#include "sim/eventq.hh"
+#include "sim/serialize.hh"
+#include "src/Config.h"
+#include "src/EventQueue.h"
+#include "src/NVMObject.h"
+#include "src/SimInterface.h"
+#include "src/TagGenerator.h"
+
+class NVMainMemory : public AbstractMemory, public NVM::NVMObject
+{
+  private:
+
+    class MemoryPort : public SlavePort
+    {
+        friend class NVMainMemory;
+
+        NVMainMemory& memory;
+        NVMainMemory& forgdb;
+
+      public:
+
+        MemoryPort(const std::string& _name, NVMainMemory& _memory);
+
+      protected:
+
+        Tick recvAtomic(PacketPtr pkt);
+
+        void recvFunctional(PacketPtr pkt);
+
+        bool recvTimingReq(PacketPtr pkt);
+
+        void recvRetry( );
+        void recvRespRetry( );
+
+        AddrRangeList getAddrRanges() const;
+
+    };
+
+    void tick();
+    void SendResponses( );
+    EventWrapper<NVMainMemory, &NVMainMemory::tick> clockEvent;
+    EventWrapper<NVMainMemory, &NVMainMemory::SendResponses> respondEvent;
+
+    void CheckDrainState( );
+    void ScheduleResponse( );
+    void ScheduleClockEvent( Tick );
+    void SetRequestData(NVM::NVMainRequest *request, PacketPtr pkt);
+
+    class NVMainStatPrinter : public Callback
+    {
+        friend class NVMainMemory;
+
+      public:
+        NVMainMemory *memory;
+        NVMainMemory *forgdb;
+
+        void process();
+
+        NVM::NVMain *nvmainPtr;
+        std::ofstream statStream;
+    };
+
+    class NVMainStatReseter : public Callback
+    {
+      public:
+        void process();
+
+        NVM::NVMain *nvmainPtr;
+    };
+
+    struct NVMainMemoryRequest
+    {
+        PacketPtr packet;
+        NVM::NVMainRequest *request;
+        Tick issueTick;
+        bool atomic;
+    };
+
+    DrainManager *drainManager;
+
+    NVM::NVMain *m_nvmainPtr;
+    NVM::Stats *m_statsPtr;
+    NVM::EventQueue *m_nvmainEventQueue;
+    NVM::GlobalEventQueue *m_nvmainGlobalEventQueue;
+    NVM::Config *m_nvmainConfig;
+    NVM::SimInterface *m_nvmainSimInterface;
+    NVM::TagGenerator *m_tagGenerator;
+    std::string m_nvmainConfigPath;
+
+    bool m_nacked_requests;
+    float m_avgAtomicLatency;
+    uint64_t m_numAtomicAccesses;
+    NVM::ncycle_t nextEventCycle;
+
+    Tick clock;
+    Tick lat;
+    Tick lat_var;
+    bool nvmain_atomic;
+
+    uint64_t BusWidth;
+    uint64_t tBURST;
+    uint64_t RATE;
+
+    bool NVMainWarmUp;
+
+    NVMainStatPrinter statPrinter;
+    NVMainStatReseter statReseter;
+    Tick lastWakeup;
+
+    uint64_t m_requests_outstanding;
+
+  public:
+
+    typedef NVMainMemoryParams Params;
+    NVMainMemory(const Params *p);
+    virtual ~NVMainMemory();
+
+    BaseSlavePort& getPort(const std::string& if_name,
+                                PortID idx = InvalidPortID);
+    void init();
+    void startup();
+    void wakeup();
+
+    const Params *
+    params() const
+    {
+        return dynamic_cast<const Params *>(_params);
+    }
+
+
+    bool RequestComplete( NVM::NVMainRequest *req );
+
+    void Cycle(NVM::ncycle_t) { }
+
+    DrainState drain() override;
+
+    void serialize(CheckpointOut &cp) const override;
+    void unserialize(CheckpointIn &cp) override;
+
+    MemoryPort port;
+    static NVMainMemory *masterInstance;
+    NVMainMemory *otherInstance;
+    std::vector<NVMainMemory *> allInstances;
+    bool retryRead, retryWrite, retryResp;
+    std::deque<PacketPtr> responseQueue;
+    std::vector<PacketPtr> pendingDelete;
+    std::map<NVM::NVMainRequest *, NVMainMemoryRequest *> m_request_map;
+
+  protected:
+
+    Tick doAtomicAccess(PacketPtr pkt);
+    void doFunctionalAccess(PacketPtr pkt);
+    void recvRetry();
+
+};
+
+#endif
+
diff --git a/src/sim/clocked_object.hh b/src/sim/clocked_object.hh
index b89e1ce13..5df404dba 100644
--- a/src/sim/clocked_object.hh
+++ b/src/sim/clocked_object.hh
@@ -78,7 +78,8 @@ class Clocked
      *  Align cycle and tick to the next clock edge if not already done. When
      *  complete, tick must be at least curTick().
      */
-    void update() const
+    void
+    update() const
     {
         // both tick and cycle are up-to-date and we are done, note
         // that the >= is important as it captures cases where tick
@@ -135,7 +136,8 @@ class Clocked
      * to be used only when the global clock is reset. Currently, this done
      * only when Ruby is done warming up the memory system.
      */
-    void resetClock() const
+    void
+    resetClock() const
     {
         Cycles elapsedCycles(divCeil(curTick(), clockPeriod()));
         cycle = elapsedCycles;
@@ -146,12 +148,8 @@ class Clocked
 
     /**
      * Update the tick to the current tick.
-     *
      */
-    inline void updateClockPeriod() const
-    {
-        update();
-    }
+    void updateClockPeriod() const { update(); }
 
     /**
      * Determine the tick when a cycle begins, by default the current one, but
@@ -167,7 +165,8 @@ class Clocked
      * this tick can be
      *     curTick() + [0, clockPeriod()) + clockPeriod() * cycles
      */
-    inline Tick clockEdge(Cycles cycles = Cycles(0)) const
+    Tick
+    clockEdge(Cycles cycles=Cycles(0)) const
     {
         // align tick to the next clock edge
         update();
@@ -184,7 +183,8 @@ class Clocked
      * to that clock edge. When curTick() is not on a clock edge, return the
      * Cycle corresponding to the next clock edge.
      */
-    inline Cycles curCycle() const
+    Cycles
+    curCycle() const
     {
         // align cycle to the next clock edge.
         update();
@@ -202,54 +202,50 @@ class Clocked
      * the future. Precisely, the returned tick can be in the range
      *     curTick() + [clockPeriod(), 2 * clockPeriod())
      */
-    Tick nextCycle() const
-    { return clockEdge(Cycles(1)); }
+    Tick nextCycle() const { return clockEdge(Cycles(1)); }
 
-    inline uint64_t frequency() const
-    {
-        return SimClock::Frequency / clockPeriod();
-    }
+    uint64_t frequency() const { return SimClock::Frequency / clockPeriod(); }
 
-    inline Tick clockPeriod() const
-    {
-        return clockDomain.clockPeriod();
-    }
+    Tick clockPeriod() const { return clockDomain.clockPeriod(); }
+
+    double voltage() const { return clockDomain.voltage(); }
 
-    inline double voltage() const
+    Cycles
+    ticksToCycles(Tick t) const
     {
-        return clockDomain.voltage();
+        return Cycles(divCeil(t, clockPeriod()));
     }
 
-    inline Cycles ticksToCycles(Tick t) const
-    { return Cycles(divCeil(t, clockPeriod())); }
-
-    inline Tick cyclesToTicks(Cycles c) const
-    { return clockPeriod() * c; }
+    Tick cyclesToTicks(Cycles c) const { return clockPeriod() * c; }
 };
 
 /**
  * The ClockedObject class extends the SimObject with a clock and
  * accessor functions to relate ticks to the cycles of the object.
  */
-class ClockedObject
-    : public SimObject, public Clocked
+class ClockedObject : public SimObject, public Clocked
 {
   public:
     ClockedObject(const ClockedObjectParams *p);
 
     /** Parameters of ClockedObject */
     typedef ClockedObjectParams Params;
-    const Params* params() const
-    { return reinterpret_cast<const Params*>(_params); }
+    const Params *
+    params() const
+    {
+        return reinterpret_cast<const Params*>(_params);
+    }
 
     void serialize(CheckpointOut &cp) const override;
     void unserialize(CheckpointIn &cp) override;
 
-    inline Enums::PwrState pwrState() const
-    { return _currPwrState; }
+    Enums::PwrState pwrState() const { return _currPwrState; }
 
-    inline std::string pwrStateName() const
-    { return Enums::PwrStateStrings[_currPwrState]; }
+    std::string
+    pwrStateName() const
+    {
+        return Enums::PwrStateStrings[_currPwrState];
+    }
 
     /** Returns the percentage residency for each power state */
     std::vector<double> pwrStateWeights() const;
